<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Nymi SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css" /> -->
<link href="customStylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top" bgcolor=#37bec4><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
<tr style="height: 0em;">
  <td id='logoBox'>
  <img  id='logoImg' src ="logo.png"></a>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
			<img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
			<img id="MSearchSelect" src="search/mag_sel.png" alt="">
			<input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_security.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Security Functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br/>
 </p>
<hr/>
<p><br/>
<br/>
</p>
<h2>Need to put in references to NCL functions, example code and perhaps use cases</h2>
<h1><a class="anchor" id="securityAPIOverview_sub"></a>
Security API Overview </h1>
<p>The Nymi SDK contains four types of security and cryptographic API functions:</p>
<ol type="1">
<li>Secret key generation: this set of functions provides the ability to generate a 128-bit long random key with an accompanying identifier, and the ability to retrieve the same key using the given identifier by the NEA that invoked the generation function.</li>
<li>Pseudorandom number generation: this is a single function that provides the ability to generate a 128-bit long pseudorandom value. This value will be output only once.</li>
<li>Local signatures: this set of functions provides the ability to generate a public private key pair (pk,sk) for the ECDSA algorithm, along with an identifier, and the ability to have the Nymi compute signatures of messages under the private key sk when the request originates from the same NEA that invoked the generation function.</li>
<li>Global signatures: this set of functions provides the required functionality to use the Nymi to check-in or authorize transactions at a terminal device that has never been provisioned to talk to this particular Nymi.</li>
</ol>
<p><br/>
 </p>
<hr/>
<p> <br/>
<br/>
</p>
<h1><a class="anchor" id="secretKeyGeneration_sub"></a>
Secret Key Geneartion </h1>
<p>This pair of functions provides the ability to generate 128-bit long keys that are, among other things, suitable for use with block ciphers such as AES-128. Specifically, there are two functions, both of which can only be invoked by a provisioned and validated NEA:</p>
<ol type="1">
<li>Key generation. This function takes no inputs, and results in a callback event containing two values: id_K, K. Both id_K, and K are 16-byte arrays. K itself can be used by the NEA in any application that requires a secret 128-bit long value, such as file or disk encryption, random password derivation, etc. K should not be stored in memory by the NEA beyond the minimal amount of time necessary to perform the cryptographic operations on K, nor should K be ever written to persistent storage. Instead, whenever K needs to be used again, the NEA should invoke the key retrieval function that is described below.</li>
<li>Key retrieval. This function takes a single input: id_K. If the currently connected NEA has previously called the key generation function, and the resulting event returned a key K and identifier id_K, then calling the key retrieval function with id_K will result in an event containing K.</li>
</ol>
<p>Example: Key Generation</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> createSkCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    uint8_t key[16], <span class="keywordtype">id</span>[16];</div>
<div class="line"></div>
<div class="line">    memcpy(key, e.<a class="code" href="struct_ncl_event.html#a5e738b6e0fd6e4ccfbc045d6e5a60d60">createdSk</a>.key, 16);</div>
<div class="line">    memcpy(<span class="keywordtype">id</span>, e.<a class="code" href="struct_ncl_event.html#a5e738b6e0fd6e4ccfbc045d6e5a60d60">createdSk</a>.<a class="code" href="struct_ncl_event_created_sk.html#a7c6c89dee983d230dd61acdc1982a035">id</a>, 16);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write code to store id somwhere</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use key to encrypt something</span></div>
<div class="line">    bsl_aes_eval(&amp;key, &amp;input, &amp;output);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Example: Key Retrieval </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> gotSkCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    uint8_t key[16]</div>
<div class="line"></div>
<div class="line">    memcpy(key, e.<a class="code" href="struct_ncl_event.html#a4133cbc987d1a02e7a20cc4cd472c30b">gotSk</a>.key, 16);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use key to decrypt something</span></div>
<div class="line">    bsl_aes_invert(&amp;key, &amp;input, &amp;output);</div>
<div class="line">}</div>
</div><!-- fragment --><p><br/>
 </p>
<hr/>
<p><br/>
<br/>
</p>
<h1><a class="anchor" id="pseudorandomNumberGeneration_sub"></a>
Pseudorandom number generation </h1>
<p>This function provides a tool for generating pseudorandom values. The produced values can in turn be used as random seeds in any procedure that requires a uniformly random input. The following function can only be invoked by a provisioned and validated NEA:</p>
<ol type="1">
<li>Pseudorandom number generation. This function takes no inputs, and the resulting event contains a single 16-byte long value that is indistinguishable from a uniformly random 16-byte sequence.</li>
</ol>
<div class="fragment"><div class="line">Example code:</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> prgCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    <span class="comment">// set the seed to the returned pseudorandom value</span></div>
<div class="line">    memcpy(userdata, e.<a class="code" href="struct_ncl_event.html#ae9383f9b3b1c9685674f877f575ee7fe">prg</a>.<a class="code" href="struct_ncl_event_prg.html#a69e1aea8181df300a848cd377c995d2c">value</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> uint8_t seed[16];</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> nymiHandle</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> randomizeSeed() {</div>
<div class="line">    <a class="code" href="group__security_functions.html#ga2586c97f9b96ff731b6b565394ccd7f4">nclPrg</a>(nymiHandle);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="comment">// Initialize NCL</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__core_functions.html#ga1fabff6d12470f7a99ee83fbf4afcd11">nclAddBehavior</a>(prgCallback, seed, <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba950a2153aa13c04506c2d3165c62643a">NCL_EVENT_PRG</a>, nymiHandle);</div>
<div class="line">    randomizeSeed();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do stuff that requires randomness</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p><br/>
 </p>
<hr/>
<p><br/>
<br/>
</p>
<h1><a class="anchor" id="localSignatures_sub"></a>
Local Signatures </h1>
<p>This pair of functions provides the ability to create a public-private key pair for the ECDSA algorithm instantiated with the NIST P-256 or secp256k1 curves. The private key is kept internally on the Nymi, and is never output. The public key is returned to the NEA, and can be used in any application that uses ECDSA digital signatures with the above curves. Examples include: TLS binding, SSH, and Bitcoin.</p>
<ol type="1">
<li>Key pair generation. This function takes a single input: the curve to be used for generating the key pair. The resulting event contains two values: vk_id and vk. vk_id is a 16-byte identifier that can be used by the NEA to access the signing functionality that is described below. vk is a 64-byte ECDSA public key that can be used by applications to verify signatures that are produced by the signing function.</li>
<li>Signing. This functions takes two inputs: a public key identifier vk_id, and a 16-byte message to be signed. The resulting event contains a single 64-byte value, which the signature of the given message under the secret key that matches the public key vk, which in turn has been returned together with vk_id as a response to an invocation of the key pair generation function by the currently connected NEA.</li>
</ol>
<p>The following function can be invoked locally by any application without connecting to a Nymi:</p>
<ol type="1">
<li>Verification. This function takes four inputs: a public key vk, a message, a signature, and a signature scheme identifier. The function verifies the signature of the message with respect to the public key vk, using the specified signature scheme. Currently the supported schemes are ECDSA with the NIST P-256 or secp256k1 curves. This function will typically be used to confirm or prove that a Nymi indeed signed a particular transaction. Note that signatures produced by the Nymi can be verified using most standard ECDSA implementation, and this function is provided for convenience.</li>
</ol>
<div class="fragment"><div class="line">uint8_t public_key[64], signature[64];</div>
<div class="line">uint8_t public_key_id[16];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> createSigKeysCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    memcpy(public_key, e.<a class="code" href="struct_ncl_event.html#a88b8eae191c7128f5effd7dc87fff752">vk</a>.<a class="code" href="struct_ncl_event_vk.html#a9a62c80fab5a7d65f654933fb5f0680a">vk</a>, 64);</div>
<div class="line">    memcpy(public_key_id, e.<a class="code" href="struct_ncl_event.html#a88b8eae191c7128f5effd7dc87fff752">vk</a>.<a class="code" href="struct_ncl_event_vk.html#a3fc3b8ba3422aaabb10684e3eb9212f0">id</a>, 16);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> signatureCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    memcpy(signature, e.<a class="code" href="struct_ncl_event.html#a3a8e1f67d11cddda4af81f10b427450a">sig</a>.<a class="code" href="struct_ncl_event_sig.html#a8c89e7948f81d7f3b7c8d79fde16de96">sig</a>, 64);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="comment">// Initialize NCL</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> create_keys() {</div>
<div class="line">    <a class="code" href="group__core_functions.html#ga1fabff6d12470f7a99ee83fbf4afcd11">nclAddBehavior</a>(createSigKeysCallback, public_key, <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba45757a864b32e8a6bb2cca33e3fe2f99">NCL_EVENT_VK</a>, nymiHandle);</div>
<div class="line">    <a class="code" href="group__security_functions.html#ga1e548b171b7be9bfea86d531fb87ea90">nclCreateSigKeyPair</a>(nymiHandle, <a class="code" href="group__security_types.html#ggab1a381edb21be3d6d446b8efec8555a0a8936fe14000076e3a16a72ed6a2c0fcb">NCL_NIST256P</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> sign_transaction() {</div>
<div class="line">    uint8_t* tx = <span class="stringliteral">&quot;Send $100 to Bob&quot;</span>;</div>
<div class="line">    uint8_t* tx_hash_raw[32];</div>
<div class="line"></div>
<div class="line">    bsl_sha256_Raw(tx, len(tx), tx_hash);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__core_functions.html#ga1fabff6d12470f7a99ee83fbf4afcd11">nclAddBehavior</a>(signatureCallback, signature, <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bac2b83ce6855dc57644bfb44106f6ab1a">NCL_EVENT_SIG</a>, nymiHandle);</div>
<div class="line">    <a class="code" href="group__security_functions.html#ga74c070e86c3ebef46162dcdd4e93b24f">nclSign</a>(nymiHandle, public_key_id, tx_hash_raw);</div>
<div class="line">}</div>
</div><!-- fragment --><p> <br/>
 </p>
<hr/>
<p><br/>
<br/>
</p>
<h1><a class="anchor" id="globalSignatures_sub"></a>
Global Signatures </h1>
<p>This set of functions provides the tools to create applications that allow a user to check-in, pay, or confirm another type of transaction to a terminal that it encounters for the first time. Some example use cases are checking into flights at the airport, unlocking a door to a meeting room, using a loyalty program, or digitally signing a contract. There are three functions related to global signatures. The first, key generation, can be only invoked by a provisioned and validated NEA:</p>
<ol type="1">
<li>Key pair generation. This function takes two inputs: a partner public key, and a Bionym signature of that public key. These inputs will be provided to partners by Bionym directly. Note that if the Nymulator is being used, the Bionym signature need not be obtained from Bionym, and can be any value (for example, all zeros). If a physical Nymi is used, a valid Bionym signature is needed. The resulting event will contain two values: vk_id and vk. vk_id is a 16-byte identifier, and vk is a 64-byte long ECDSA public key. For now, this functionality supports only the NIST P-256 curve for ECDSA.</li>
</ol>
<p>In a typical use case, the NEA calling the above function will be a sign-up app provided by a 3rd party such as an airline, payments provider, or physical access provider. After obtaining vk_id and vk, this NEA will typically transmit both values to a remote server, which will associate the pair (vk_id, vk) with a user profile. The user profile is application specific.</p>
<div class="fragment"><div class="line"><span class="comment">// The following code will run on a sign up app</span></div>
<div class="line">uint8_t partnerPk[64], bionymSig[64], gsigPk[64], vkId[16];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> createSigKeysCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    memcpy(gsigPk, e.<a class="code" href="struct_ncl_event.html#a88b8eae191c7128f5effd7dc87fff752">vk</a>.<a class="code" href="struct_ncl_event_vk.html#a9a62c80fab5a7d65f654933fb5f0680a">vk</a>, 64);</div>
<div class="line">    memcpy(vkId, e.<a class="code" href="struct_ncl_event.html#a88b8eae191c7128f5effd7dc87fff752">vk</a>.<a class="code" href="struct_ncl_event_vk.html#a3fc3b8ba3422aaabb10684e3eb9212f0">id</a>, 16);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> create_keys() {</div>
<div class="line">    <a class="code" href="group__core_functions.html#ga1fabff6d12470f7a99ee83fbf4afcd11">nclAddBehavior</a>(createSigKeysCallback, gsigPk, <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba326eb1ab1ae39df4523c0280b0674aa4">NCL_EVENT_GLOBAL_VK</a>, nymiHandle);</div>
<div class="line">    <a class="code" href="group__security_functions.html#ga9311088ac47718e755004e52b165ef36">nclCreateGlobalSigKeyPair</a>(nymiHandle, partnerPk, bionymSig);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="comment">// set partnerPk, bionymSig, partnerSk, and initialize NCL</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Preparing a Global Sign Request</h2>
<p>The following function can be computed locally (without connecting to a Nymi) by any device that has the partner private key. The private key will be issued to partners by Bionym along with the above mentioned partner public key and Bionym signature.</p>
<ol type="1">
<li>Sign advertisement (nclSignAdv). This function takes three inputs: a target Nymi's advertisement nonce, a message that the Nymi should sign eventually, and the partner private key. Typically, this function will be called by a remote server, which will receive a request from a terminal over the Internet (securing the connection between the terminal and the server is out of the scope of this document). A request will typically be sent by a terminal when it detects a Nymi nearby, and wishes to identify it or get a transaction signed by the Nymi. The terminal will obtain the Nymi's advertisement nonce by calling nclGetAdv, and sending the resulting 16-byte value to the server.</li>
</ol>
<p>The server then computes the message to be signed by the Nymi. This is application specific, but in most check-in scenarios, it can be a random 16-byte value. The server then invokes this function (nclSignAdv) and passes the Nymi's advertisement nonce, the message to be signed, and the partner private key. The function will then return a 64-byte long signature, which the server should send back to the terminal.</p>
<div class="fragment"><div class="line"><span class="comment">// The following code will run on the server</span></div>
<div class="line">uint8_t partnerSk[32];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> signWithPartnerSk(uint8_t* serverMessage, uint8_t* nymiAdvNonce, uint8_t* signature) {</div>
<div class="line">    <a class="code" href="group__security_functions.html#ga24a705ee95855c9456e55b1e37ed89ad">nclSignAdv</a>(nymiAdvNonce, serverMessage, partnerSk, signature);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In the above, nymiAdvNonce can be obtained by the terminal by calling nclGetAdv, and sent to the server for signing.</span></div>
</div><!-- fragment --><h2>Initiating a Global Sign request</h2>
<p>The following function can be invoked by any device that connects to the Nymi via BLE. Typically, such a device will be a terminal, door lock, or point of sale device. Typically, the device will not establish any long term relationship with the Nymi.</p>
<ol type="1">
<li>Global sign. This function takes three inputs: the server signature, the partner public key, and the message to be signed by the Nymi. The first input is provided to the terminal by the remote server (as described above). The partner public key can be stored locally on every terminal instance, or retrieved from a server. The message must be the same value that was used by the server to compute the server signature. The resulting event will contain two values: vk_id and and a Nymi signature sig. vk_id is a 16-byte long identifier, which matches the identifier vk_id that was given to the NEA that called the global signatures key generation function (1 above). The terminal will typically pass both vk_id and sig to the remote server. The server will then look up the vk value and the user profile that are associated with vk_id. The server will then invoke nclVerify, passing inputs vk, message, and sig, where message is the original message that the server wanted the Nymi to sign. The signature scheme for global signatures is always NCL_NIST256P.</li>
</ol>
<p>If nclVerify returns true, the cryptographic signature has been successfully verified, and the server can proceed under the assumption that the same person that registered in step 1 above is currently interacting with the terminal that initiated the query. <br/>
</p>
<div class="fragment"><div class="line"><span class="comment">// The following code will run on the terminal, after obtaining a signature from the server</span></div>
<div class="line"></div>
<div class="line">uint8_t signature[64], partnerPk[64], vkId[16];</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> signatureCallback(<a class="code" href="struct_ncl_event.html">NclEvent</a> e, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    memcpy(signature, e.<a class="code" href="struct_ncl_event.html#abb204c6dd967bbaa101e1072ea039af8">globalSig</a>.<a class="code" href="struct_ncl_event_global_sig.html#acdedd413baa7520d36d3f546bc29eabe">sig</a>, 64);</div>
<div class="line">    memcpy(vkId, e.<a class="code" href="struct_ncl_event.html#abb204c6dd967bbaa101e1072ea039af8">globalSig</a>.<a class="code" href="struct_ncl_event_global_sig.html#af8a3f549b3d26c5a07de360569f635c7">vkId</a>, 16);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Code to send signature and vkId for verification on the server</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> signTransaction(uint8_t* advSig, uint8_t* message) {</div>
<div class="line">    <a class="code" href="group__core_functions.html#ga1fabff6d12470f7a99ee83fbf4afcd11">nclAddBehavior</a>(signatureCallback, signature, <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba81e5a6f6e22cf58898426ef039f09d6f">NCL_EVENT_GLOBAL_SIG</a>, nymiHandle);</div>
<div class="line">    <a class="code" href="group__security_functions.html#gaca668c6614f5e446c57d0c5e936fb01b">nclGlobalSign</a>(nymiHandle, advSig, partnerPk, message);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// The server can verify the signature produced by the Nymi as follows</span></div>
<div class="line"><span class="comment">// upon receiving signature and vkId, look up the corresponding gsigPk based on vkId, and compute</span></div>
<div class="line"><a class="code" href="group__security_functions.html#ga5aee8e1feea0c3eb5b83fc2a069ea913">nclVerify</a>(gsigPk, message, signature, <a class="code" href="group__security_types.html#ggab1a381edb21be3d6d446b8efec8555a0a8936fe14000076e3a16a72ed6a2c0fcb">NCL_NIST256P</a>);</div>
<div class="line"><span class="comment">// Here, message is the server message that the Nymi was supposed to sign</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--   <ul>
    <li class="footer">Copyright Bionym 2013. Generated on Thu Dec 18 2014. Version 0.1.0</li>
  </ul> -->
</div>
<!-- end header part -->
